# 汇编中的寻址

### x64的函数调用寻址

示例代码

```C
int func1(){
    return 1;
}
int main() {
    func1();
}
```

反编译后得到汇编代码如下:

```asm
00000000004004b2 <func1>:
  4004b2:       55                      push   %rbp
  4004b3:       48 89 e5                mov    %rsp,%rbp
  4004b6:       b8 01 00 00 00          mov    $0x1,%eax
  4004bb:       5d                      pop    %rbp
  4004bc:       c3                      retq   

00000000004004bd <main>:
  4004bd:       55                      push   %rbp
  4004be:       48 89 e5                mov    %rsp,%rbp
  4004c1:       b8 00 00 00 00          mov    $0x0,%eax
  4004c6:       e8 e7 ff ff ff          callq  4004b2 <func1>
  4004cb:       b8 00 00 00 00          mov    $0x0,%eax
  4004d0:       5d                      pop    %rbp
  4004d1:       c3                      retq   
  4004d2:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  4004d9:       00 00 00 
  4004dc:       0f 1f 40 00             nopl   0x0(%rax)
```

如果调用函数在同一个模块中时，一般采用相对寻址的方式，也就是这里的4004c6处地址上的汇编码`e8 e7 ff ff ff`，后面的字符串是反编译为了让我们更好的观看而已，为何能调用到`func1`呢？

解析`e8 e7 ff ff ff`，其中e8为call指令码，后面的汇编码是小端排序的，也就是数据`0xffffffe7`，这是一个补码形式，具体表示的是-25，仔细观察当前汇编所在的位置`0x4004c6`，通过`0x4004c6 - 25 + 5`后得到`0x4004b2`，也就是真正的`func1`地址， __至于为何+5，这是由于当前的call指令和地址占据了5Bytes，需要扣去__ 。这就是函数的相对寻址。

### x86数据寻址

按理来说，数据段和代码段同样存在不变的某个相对地址，也是可以通过相对地址来进行寻址的，但遗憾的是，在x86的架构下，不允许这样做。

所以要做数据相对寻址，就需要用到一个其他的办法来获取当前的地址，并且通过当前地址加上相对地址来获得数据的地址。

我们可以知道，在x86架构下，EIP保存着当前指令的下一段指令的地址，我们可以通过这个办法来获取地址，C/C++反汇编中常常看到的`get_pc_thunk.寄存器名字`，就是来做这件事情的。

比如`get_pc_thunk.eb`这个函数的指令非常少，只有短短2行，和普通函数相比，甚至连ebp的保护都没有。

```asm
mov (%esp), %ebx
ret
```

首先将esp处数据赋值给ecx，这是由于函数调用时call指令会将eip入栈作为返回地址，而我们进入函数并没有保存ebp，而是直接将EIP(esp处的数据就是EIP)赋值给ebx，并且直接ret了。

__这样以来，当调用结束后，我们就得到了一条指令的地址了，再扣去指令长度和相对地址，就可以得到数据的地址了，这就是数据的相对寻址__ 。

比如

```asm
call get_pc_thunk.eb
mov 0x20(%ebx), %eax # 将ebx偏移0x20的数据赋给eax寄存器
```

### x64寻址

x64就相对简单很多了，因为有了新方法，对于函数而言，和x86一样，而对于数据，则直接允许我们使用RIP寄存器来寻址，比如

```asm
mov 0x20(%rip), %rax # 通过下条指令的RIP地址+0x20的偏移量处的地址赋给rax寄存器
```

