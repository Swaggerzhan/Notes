# C++ exp

### 1. static 关键字

```C++
#include <iostream>

static void f4();
static int t;

class Test{
public:

    Test();
    void f1();
    void f2();
    static void f3();
    
public:
    int x;
    int y;
    static int z; /* static 关键字 */
};


void f5(){
    static int i = 10;
    i++;
}
```

(C++)
关于static修饰的变量，如变量z，它是个`类变量`， __所有由这个类实例出来的对象都可以访问，并且它只有一份copy，位于全局数据区域。__ 类变量必须在`类外定义`，如果没有赋予初始值，由于位于全局数据区， __所以一般为0 (动态区如栈或者堆一般为垃圾值)。__ sizeof计算一个对象的大小不包含static修饰的变量。

被static修饰的类函数也是如此，它将变成`类方法`，这个类实例出来的对象都可以访问到。只不过有一个地方相反， __即static方法里访问不到this指针！。__ 
(C)
对于全局静态变量如`t`， __保存在全局数据区，它不被其他文件所访问，如果文件`File1`中包含此全局静态变量。则`File2`文件是无法访问到的，即使是使用extern提前声明都不行。__ 
局部静态变量`i`同样保存在 __全局数据区__ ，所以将导致整个函数调用结束后， __`f5()`函数中的其他数据会被销毁(其他数据放在栈中)，下次调用`f5()`时，`i`的数据和上次调用一样。__
静态函数`f4()`函数只能在定义的文件中使用，和全局静态变量相似。

注： __当一个头文件只有头文件存在时，那么所有文件只要包含此头文件即可访问其中的static修饰的变量或者函数，如果这个头文件存在对应的.c或者.cpp文件存在，那么其他文件无法访问static修饰的变量或者函数。__ (本质是编译器对.h等头文件等的不同处理方式)

暂时理解：单独的一个.h文件被include时会被单独的复制代码到include它的文件中，编译的时候也不会出现单独.o文件，它和include它的文件融合为一体了。也就没有了链接器找不到的问题。

### 2. 类的构造函数

```C++
class Gun{
public:
    int money;
    int distance;

public:
    
    /**
     * 列表构造函数
     **/
    Gun(int m, int dis):money(m), distance(dis){
        printf("构造函数1.0\n");
    }
    
    /**
     * 赋值构造函数
     **/
    Gun(int m, int dis){
        this->money = m;
        this->distance = dis;
    }
    
    Gun(){
        this->money = 1000; /* 默认值 */
        this->distance = 800;
        printf("构造函数2.0\n");
    }
    
    /**
     *  拷贝构造函数
     */
    Gun(Gun &g){
        this->money = g.money
        this->distance = g.distance;
        printf("构造函数3.0\n");
    }
    
};
```

类在被实例化的时候都会调用 __构造方法__ ，即使没有显式的写出，编译器也会为其添加所谓的构造函数，构造函数可以使用列表方式，这种方式的效率更高一些。
 __构造函数可以有多个，即重载__ ，如上例子，使用`Gun *g = new Gun(1, 2);`调用`1.0方式的构造函数`，而`Gun *g = new Gun();`则会调用`2.0的构造函数`。
 拷贝构造函数在一个对象进行拷贝时候会调用，如果没有显式的定义，它也会存在，只不过会出现一些`浅拷贝问题`， __即拷贝后的对象和拷贝前的对象中的指针指向相同区域的内存。__
 
### 3. 右值引用

```C++
/* a可以取地址，是左值，10不可以取地址，是右值 */
int a = 10;


class A{
public:
    A();
    A(A& a);

};

A a1; // 这里没有调用拷贝构造函数
/* a2可以取地址，是左值，A()不可以取地址，是右值 */
A a2 = A(); // 这里其实会调用拷贝构造函数！
```

区分左右值的方式最直观的就是判断是否可以取地址。
```C++
int a = 10;
int &a_ref = a; // 左值引用指向左值，正确
int &b_ref = 10; // 左值引用指向右值，错误
const &c_ref = 10; // const左值引用可以指向右值，正确
```
由于const左值引用不会改变值，所以它可以指向右值，所以许多函数将 `const &`作为参数，可以降低拷贝成本。


### 4. const关键字

```C++
/* 这两者本质没啥区别 */
int const x = 10;
const int y = 20;


const int *p1 = &x; /* p1指向的数值不可修改 */
/* 这里我们不能通过*p1修改x的值，但是我们可以直接修改x的值 */
x = 20; // 这里将导致*p1的值变为20
/* 不能修改*p1的值，但是我们可以将p1赋值为其他的地址 */
p1 = &y; // 这里将导致*p1的值变为20


int const *p2 = &x; /* p2的数值不可修改 */
/* 我们可以使用x直接修改*p2的值 */
x = 20; // 这里将导致*p2的值为20
/* 我们也可以使用*p2修改 */
*p2 = 20; // 这里将导致*p2的值为20

/* 指针和指向的值都不可以改 */
const int* const p1 = &x;
x = 1000; // 即时如此我们还是可以通过修改x来修改*p1的值

```

当在类中使用时候

```C++
class Test{

public:

    const int test; // 不能修改，只能在对象初始化的时候初始化
    
    int x;
    int y;
    
public:

    Test(int t): test(t){}

    void test1() const; // 常成员函数
    
    void test2();

};
```
其中 __test1()常成员函数是无法修改普通对象中的x和y的值__ ，这是由于const修饰的就是`this`指针。也就是`void test1() const;`其实是`void test1(const Test* this);`，还记得之前的定义么，这种定义的意思表示的是 __无法修改`this`指向的地址处的值，所以自然无法修改其中x和y的值。__ 

```C++
const Test* t = new Test(10);
t->test1();
```
常成员函数只能调用常成员函数。
常对象只能调用常成员函数。

```C++
/* 限制的是指针指向的值，所以不能调用其他方法，只能调用常成员函数 */
const Test* t = new Test(10);
/* 限制的是指针的值，对于指针指向的值不影响，所以所有函数都能调用 */
Test* const t = new Test(20);

```


