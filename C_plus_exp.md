# C++ exp

### 1. static 关键字

```C++
#include <iostream>

static void f4();
static int t;

class Test{
public:

    Test();
    void f1();
    void f2();
    static void f3();
    
public:
    int x;
    int y;
    static int z; /* static 关键字 */
};


void f5(){
    static int i = 10;
    i++;
}
```

(C++)
关于static修饰的变量，如变量z，它是个`类变量`， __所有由这个类实例出来的对象都可以访问，并且它只有一份copy，位于全局数据区域。__ 类变量必须在`类外定义`，如果没有赋予初始值，由于位于全局数据区， __所以一般为0 (动态区如栈或者堆一般为垃圾值)。__ sizeof计算一个对象的大小不包含static修饰的变量。

被static修饰的类函数也是如此，它将变成`类方法`，这个类实例出来的对象都可以访问到。只不过有一个地方相反， __即static方法里访问不到this指针！。__ 
(C)
对于全局静态变量如`t`， __保存在全局数据区，它不被其他文件所访问，如果文件`File1`中包含此全局静态变量。则`File2`文件是无法访问到的，即使是使用extern提前声明都不行。__ 
局部静态变量`i`同样保存在 __全局数据区__ ，所以将导致整个函数调用结束后， __`f5()`函数中的其他数据会被销毁(其他数据放在栈中)，下次调用`f5()`时，`i`的数据和上次调用一样。__
静态函数`f4()`函数只能在定义的文件中使用，和全局静态变量相似。

注： __当一个头文件只有头文件存在时，那么所有文件只要包含此头文件即可访问其中的static修饰的变量或者函数，如果这个头文件存在对应的.c或者.cpp文件存在，那么其他文件无法访问static修饰的变量或者函数。__ (本质是编译器对.h等头文件等的不同处理方式)

暂时理解：单独的一个.h文件被include时会被单独的复制代码到include它的文件中，编译的时候也不会出现单独.o文件，它和include它的文件融合为一体了。也就没有了链接器找不到的问题。

### 2. 类的构造函数

```C++
class Gun{
public:
    int money;
    int distance;

public:
    
    /**
     * 列表构造函数
     **/
    Gun(int m, int dis):money(m), distance(dis){
        printf("构造函数1.0\n");
    }
    
    /**
     * 赋值构造函数
     **/
    Gun(int m, int dis){
        this->money = m;
        this->distance = dis;
    }
    
    Gun(){
        this->money = 1000; /* 默认值 */
        this->distance = 800;
        printf("构造函数2.0\n");
    }
    
    /**
     *  拷贝构造函数
     */
    Gun(Gun &g){
        this->money = g.money
        this->distance = g.distance;
        printf("构造函数3.0\n");
    }
    
};
```

类在被实例化的时候都会调用 __构造方法__ ，即使没有显式的写出，编译器也会为其添加所谓的构造函数，构造函数可以使用列表方式，这种方式的效率更高一些。
 __构造函数可以有多个，即重载__ ，如上例子，使用`Gun *g = new Gun(1, 2);`调用`1.0方式的构造函数`，而`Gun *g = new Gun();`则会调用`2.0的构造函数`。
 拷贝构造函数在一个对象进行拷贝时候会调用，如果没有显式的定义，它也会存在，只不过会出现一些`浅拷贝问题`， __即拷贝后的对象和拷贝前的对象中的指针指向相同区域的内存。__
 
### 3. 右值引用

```C++
/* a可以取地址，是左值，10不可以取地址，是右值 */
int a = 10;


class A{
public:
    A();
    A(A& a);

};

A a1; // 这里没有调用拷贝构造函数
/* a2可以取地址，是左值，A()不可以取地址，是右值 */
A a2 = A(); // 这里其实会调用拷贝构造函数！
```

区分左右值的方式最直观的就是判断是否可以取地址。
```C++
int a = 10;
int &a_ref = a; // 左值引用指向左值，正确
int &b_ref = 10; // 左值引用指向右值，错误
const &c_ref = 10; // const左值引用可以指向右值，正确
```
由于const左值引用不会改变值，所以它可以指向右值，所以许多函数将 `const &`作为参数，可以降低拷贝成本。


