## 普通的面试问题
### 1. 如何检测内存越界读写？

如果是一些简单的数组越界写的话可以使用一些检测工具，如vargrind进行检测，一般都能查出来。如果是一些竞态读写问题的话就需要调试了，或者在编写代码的时候就明确对象由哪些线程初始化，哪些线程来回收。有些竞态需要一些压力测试才会出现这种问题，一般是直接压爆查看coredump来看，如果只是简单的越界读写就可直接看到元凶了，或者就通过backtrace来查看调用栈之类的，如果读取到一些不该读的东西可以在某些线程再多加点log，多打点log，然后多assert点条件，争取在其他线程改前就提前找到一些线索之类的。


总结：
1. 如果简单的数组越界写，可以直接通过vargrind等检测工具查。
2. 如果是竞态读写问题，就需要一些压力测试，压爆后看coredump和backtrace，当然如果日志允许的话，多打点log也能看出点端倪，又或者在其他线程可能修改某些资源时提前assert，发现某些线程在不该写的时候读写了某些资源直接让它挂掉。

### 2. lambda表达式作用？

我很少用到lamdba表达式，如果有的话就是用来模拟类似go语言的go关键字，先实现一个线程池，然后用lambda表达式实现一个匿名函数，然后直接丢到线程池中，从逻辑来模仿一个类似go关键字的功能。

### 3. gdb调试？

比较常用的比如b下断点，p看内存，bt看调用栈，info看各种信息之类的，或者disassemble看某个函数的汇编语言这些会用的比较多吧，如果多线程哪些话可能thread切换线程拉，又或者用scheduler-lock来设置一些断点让所有线程都停下来还是只有当前停下来之类的。


### 4. 多路复用的难点

### 5. vector的一些问题

1. 扩容问题： 在gcc下是2，vs下就不清楚了，可能是1.5？
2. push_back和emplace_back的区别：感觉区别最大的是emplace_back采用原地构造的方式，少了一个内存拷贝。

### 6. 右值引用

我的理解是更像一个将亡值，如果不能取地址，并且下条语句就失去生命的对象就是右值，右值引用就是用来绑定右值的，主要是用来做移动语意和完美转发的，可以减少点拷贝操作，更像是浅拷贝的东西，但是原先的值就不能再用了。

### 7. struct 内存对齐 和 类的成员函数

主要是由于cpu取内存数据总是某些倍数长度来取的，没有对齐的话可能需要多次才能访问到一个完整的变量，对齐能提高访问的效率。
Linux下的pack默认好像是4.
对于strcut一般要求起始地址为某个倍数，然后对于里面的成员,一般要求其起始位置相对于结构体开头的offset是本身变量大小的一个整数倍，如果不够，从前面的变量中不齐不够的字节。

类成员函数倒是不会占用内存，存在rodata区域，一般是只读区域中，占用位置的是虚函数，一般占用一个指针大小，虚函数表也一般在rodata中，至少gcc是这样的。

ps：虚函数，一般是由于一个虚函数指针和虚拟函数表实现的，虚指针在对象内存开头，虚函数表在rodata区，只要有virtual关键字就有所谓的虚函数指针，每个类都有对应的虚函数表，也能继承，继承后也能修改，主要用来实现运行时的多态。多态的话我不知道怎么用专业的文字描述，用一个基类指针进行函数调用，得到的是基于内存的对象的函数调用，跟基类指针无关。

### 8. TCP和UDP区别，为什么不直接使用IP而使用UDP？

TCP的话是数据流，如果处理不好会有所谓的粘包问题，但是TCP本身就是流数据，所以对于一些数据包是需要上层协议来进行区分的，UDP就没有这种问题了，该是一个包就是一个包，拿到的就是一个个包，有点类似离散数据内味，IP的话是跑在网络层的东西，主要用于路由，而且也没有规定哪个应用程序来处理，IP只能到主机层面，无法确认是哪个引用程序来处理，主要是端口问题吧。

### 9. TCP如何保证传输的稳定？

主要是ARQ协议吧，当一段时间后还没有收到对应ack，则进行重传，或者对段要求重传等。

### 10. 构造函数是虚函数

没啥意义吧，如果是虚函数的话，就是表示不想在编译时确定，那就是需要vptr，但是构造函数本身就是创建vptr的，既要用vptr，也要通过vptr来构造函数，本身就是无解的，而且gcc不允许这样做，编译就过不去了。

纯虚函数的话感觉就是多了一个派生类必须实现这个东西，其余的并没有多大区别，更多的是用来写接口的感觉。



## 关于项目

### 1. 项目遇到什么问题，怎么解决的

我一开始遇到了一个对象初始化的问题，把太多的东西放到了对象的初始化函数中，然后由于某些问题，对象初始化失败了，然后就导致内存都泄漏了，后面就改成用二段式的初始化方式了，因为我目前用try catch方式比较少，更多的是使用retcode的方式来判断错误，所以也就使用了二段式来判断对象是否初始化成功了，改成这样后程序就比较稳定了。